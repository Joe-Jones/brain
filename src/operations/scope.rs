use std::rc::Rc;
use std::collections::{VecDeque, HashMap};

use parser::{Identifier, Number};
use memory::{StaticAllocator, MemoryBlock};

use super::OperationsResult;
use super::item_type::ItemType;

pub type TypeId = usize;

/// The arguments that will get passed to a function
/// Arguments are guaranteed by static analysis to match the type defined for the function
pub type FuncArgs = Vec<ScopeItem>;

/// Represents a single item in a scope
#[derive(Clone)]
pub enum ScopeItem {
    /// A type, not associated with any memory
    /// Used for a struct/type declaration, not the declaration
    /// of a variable with a type (TypedBlock should be used for that)
    Type(TypeId),

    /// A constant set of bytes inlined whenever used
    /// These items have no memory address
    /// The bytes of the constant are stored directly
    Constant {
        type_id: TypeId,
        /// Size of bytes must match the required size of type_id
        bytes: Vec<u8>,
    },

    /// A constant value that represents a numeric literal without a specific number type
    /// Stored in a temporary memory location for non-built-in functions
    NumericLiteral(Number),

    /// A typed block of memory
    TypedBlock {
        type_id: TypeId,
        memory: MemoryBlock,
    },

    /// A built-in function definition
    BuiltInFunction {
        /// The ID of the type associated with this function
        id: TypeId,
        /// Generates operations that represent calling the
        /// function with the given arguments
        operations: Rc<Fn(&mut ScopeStack, FuncArgs) -> OperationsResult>,
    },
}

/// Represents a single level of scope
pub type Scope = HashMap<Identifier, ScopeItem>;

pub struct ScopeStack {
    stack: VecDeque<Scope>,
    allocator: StaticAllocator,
    /// A vector of all the declared types used to produce unique identities
    /// for all types so that types are static and not dependent on the context
    /// in which they are used.
    /// Basically, if we declare a type Foo and a variable with that type,
    /// we don't want a later declaration of Foo change the type of the variable
    /// Also used in functions/closures to uniquely refer to types in that context
    types: Vec<(Identifier, ItemType)>,

    /// The TypeId that corresponds with the bool type
    bool_type_id: Option<TypeId>,
    array_type_id: Option<TypeId>,
}

impl ScopeStack {
    pub fn new() -> ScopeStack {
        ScopeStack {
            stack: {
                let mut queue = VecDeque::new();
                queue.push_back(Scope::new());
                queue
            },
            allocator: StaticAllocator::new(),
            types: vec![(Identifier::from("()"), ItemType::Unit)],
            bool_type_id: None,
            array_type_id: None,
        }
    }

    /// Pushes a new level of scope onto the stack
    /// This scope will become the current scope
    pub fn push_scope(&mut self) {
        self.stack.push_back(Scope::new());
    }

    /// Removes and returns the top level scope (current scope)
    ///
    /// # Panics
    /// Panics if there is no scope in the stack
    pub fn pop_scope(&mut self) -> Scope {
        self.stack.pop_back().unwrap()
    }

    /// Returns the type name associated with the given TypeId
    pub fn get_type_name(&self, type_id: TypeId) -> &Identifier {
        // We just unwrap here because this isn't an error that can be generated by the user's
        // mistake. If this fails, it has to be a bug in the compiler.
        &self.types.get(type_id).expect("Invalid TypeId used to lookup type").0
    }

    /// Returns the type associated with the given TypeId
    pub fn get_type(&self, type_id: TypeId) -> &ItemType {
        // We just unwrap here because this isn't an error that can be generated by the user's
        // mistake. If this fails, it has to be a bug in the compiler.
        &self.types.get(type_id).expect("Invalid TypeId used to lookup type").1
    }

    /// Returns the TypeId of the Unit `()` type
    pub fn unit_type_id(&self) -> TypeId {
        0
    }

    /// Returns the TypeId of the bool type
    pub fn bool_type_id(&self) -> TypeId {
        // NOTE: The unit type, the bool type and the array type are "special primitives". These
        // types are fundamentally required for the compiler to function and so we need to provide
        // special access to them in the scope. We want a stronger guarantee than just relying on
        // names like "bool".
        // We don't want to couple the types' implementation with this module, so we simply add a
        // hatch for the implementing modules to define which TypeId should be associated with bool

        self.bool_type_id.expect("Expected a bool TypeId to be defined in the scope")
    }

    /// Set the TypeId for the primitive bool type
    pub fn set_bool_type_id(&mut self, type_id: TypeId) {
        // NOTE: See note in bool_type_id

        // This should only be called once
        debug_assert!(self.bool_type_id.is_none(), "Redefined bool TypeId in scope");

        debug_assert!(type_id != self.unit_type_id(), "Declared bool TypeId with the same TypeId as Unit");

        self.bool_type_id = Some(type_id)
    }

    /// Returns the TypeId of the array type
    pub fn array_type_id(&self) -> TypeId {
        // NOTE: See note in bool_type_id

        self.array_type_id.expect("Expected a array TypeId to be defined in the scope")
    }

    /// Set the TypeId for the primitive array type
    pub fn set_array_type_id(&mut self, type_id: TypeId) {
        // NOTE: See note in bool_type_id

        // This should only be called once
        debug_assert!(self.array_type_id.is_none(), "Redefined array TypeId in scope");

        debug_assert!(type_id != self.unit_type_id(), "Declared array TypeId with the same TypeId as Unit");

        self.array_type_id = Some(type_id)
    }

    /// Looks up a name starting at the current scope
    /// Returns ALL matches so that the caller can determine which definition is
    /// the correct one
    /// Definitions are returned in order from latest definition to oldest
    /// Always use the first definition that matches the type you are looking for
    pub fn lookup(&self, name: &Identifier) -> Vec<&ScopeItem> {
        self.stack.iter().rev().map(|sc| sc.get(name)).fold(Vec::new(), |mut acc, r| match r {
            Some(def) => {
                acc.push(def);
                acc
            },
            None => acc,
        })
    }

    /// Declares a type with the given name
    /// Returns the unique identifier of that type
    pub fn declare_type(&mut self, name: Identifier, typ: ItemType) -> TypeId {
        let type_id = self.insert_type(&name, typ);
        self.insert_current(name, ScopeItem::Type(type_id));

        type_id
    }

    /// Declares a constant with the given name
    pub fn declare_constant(&mut self, name: Identifier, type_id: TypeId, value: Vec<u8>) {
        debug_assert!({
            let size = self.get_type(type_id).required_size(self);
            value.len() == size
        });

        self.insert_current(name, ScopeItem::Constant {
            type_id: type_id,
            bytes: value,
        });
    }

    /// Declares a name with the given type and allocates enough space for that type
    /// The name is declared in the "current" scope which is at the top of the stack
    /// Returns the allocated memory block
    pub fn declare(&mut self, name: Identifier, type_id: TypeId) -> MemoryBlock {
        let mem = self.allocate(type_id);
        self.insert_current(name, ScopeItem::TypedBlock {
            type_id: type_id,
            memory: mem,
        });

        mem
    }

    /// Allocate a memory block that is large enough for the given type
    /// Does not associate memory block with a name which means it cannot be looked up later
    /// Returns the allocated memory block
    pub fn allocate(&mut self, type_id: TypeId) -> MemoryBlock {
        let size = self.get_type(type_id).required_size(self);
        self.allocator.allocate(size)
    }

    /// Declares a built in function with the given name and type definition
    /// The name is declared in the "current" scope which is at the top of the stack
    /// The function is guaranteed to be called with arguments that match its given type signature
    /// Functions that can be called on an instance of a type should have that type as the first
    /// parameter as the "self" of that function
    pub fn declare_builtin_function<F: 'static>(&mut self, name: Identifier, typ: ItemType, f: F)
        where F: Fn(&mut ScopeStack, FuncArgs) -> OperationsResult {

        // Make sure we are declaring the function as a function type
        debug_assert!(match typ {
            ItemType::Function { .. } => true,
            _ => false,
        });

        let type_id = self.insert_type(&name, typ);
        self.insert_current(name, ScopeItem::BuiltInFunction {
            id: type_id,
            operations: Rc::new(f),
        });
    }

    /// Inserts a ScopeItem into the current scope
    fn insert_current(&mut self, name: Identifier, item: ScopeItem) {
        // Notice that we insert directly without caring about whether the name already exists
        // It's OK to overwrite existing names because we support rebinding
        if let Some(scope) = self.stack.back_mut() {
            scope.insert(name, item);
        }
        else {
            panic!("Attempt to declare name despite having no current scope");
        }
    }

    /// Inserts a type defintion into the types field and returns its new TypeId
    fn insert_type(&mut self, name: &Identifier, typ: ItemType) -> TypeId {
        self.types.push((name.clone(), typ));

        self.types.len() - 1
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use parser::Identifier;
    use operations::item_type::ItemType;

    #[test]
    fn unit_type_id() {
        let scope = ScopeStack::new();

        assert!(match *scope.get_type(scope.unit_type_id()) {
            ItemType::Unit => true,
            _ => false,
        });
    }

    #[test]
    fn bool_type_id() {
        const BOOL_TYPE_ID: TypeId = 1;

        let mut scope = ScopeStack::new();
        scope.set_bool_type_id(BOOL_TYPE_ID);

        assert_eq!(scope.bool_type_id(), BOOL_TYPE_ID);
    }

    #[test]
    #[should_panic(expected = "Declared bool TypeId with the same TypeId as Unit")]
    fn bool_type_id_is_unit() {
        let mut scope = ScopeStack::new();

        let unit_id = scope.unit_type_id();
        scope.set_bool_type_id(unit_id);
    }

    #[test]
    #[should_panic(expected = "Expected a bool TypeId to be defined in the scope")]
    fn access_bool_type_id_without_declaration() {
        let scope = ScopeStack::new();

        scope.bool_type_id();
    }

    #[test]
    #[should_panic(expected = "Redefined bool TypeId in scope")]
    fn redefine_bool_type_id() {
        let mut scope = ScopeStack::new();

        scope.set_bool_type_id(1);
        scope.set_bool_type_id(2);
    }

    #[test]
    fn array_type_id() {
        const ARRAY_TYPE_ID: TypeId = 2;

        let mut scope = ScopeStack::new();
        scope.set_array_type_id(ARRAY_TYPE_ID);

        assert_eq!(scope.array_type_id(), ARRAY_TYPE_ID);
    }

    #[test]
    #[should_panic(expected = "Declared array TypeId with the same TypeId as Unit")]
    fn array_type_id_is_unit() {
        let mut scope = ScopeStack::new();

        let unit_id = scope.unit_type_id();
        scope.set_array_type_id(unit_id);
    }

    #[test]
    #[should_panic(expected = "Expected a array TypeId to be defined in the scope")]
    fn access_array_type_id_without_declaration() {
        let scope = ScopeStack::new();

        scope.array_type_id();
    }

    #[test]
    #[should_panic(expected = "Redefined array TypeId in scope")]
    fn redefine_array_type_id() {
        let mut scope = ScopeStack::new();

        scope.set_array_type_id(2);
        scope.set_array_type_id(3);
    }

    #[test]
    fn bool_array_types_different() {
        // Make sure we are setting the right fields in the setter methods
        const BOOL_TYPE_ID: TypeId = 1;
        const ARRAY_TYPE_ID: TypeId = 2;

        let mut scope = ScopeStack::new();
        scope.set_array_type_id(ARRAY_TYPE_ID);
        assert_eq!(scope.array_type_id(), ARRAY_TYPE_ID);
        scope.set_bool_type_id(BOOL_TYPE_ID);
        assert_eq!(scope.bool_type_id(), BOOL_TYPE_ID);

        // Should not change
        assert_eq!(scope.array_type_id(), ARRAY_TYPE_ID);

        assert!(scope.bool_type_id() != scope.array_type_id());

        let mut scope = ScopeStack::new();
        scope.set_bool_type_id(BOOL_TYPE_ID);
        assert_eq!(scope.bool_type_id(), BOOL_TYPE_ID);
        scope.set_array_type_id(ARRAY_TYPE_ID);
        assert_eq!(scope.array_type_id(), ARRAY_TYPE_ID);

        // Should not change
        assert_eq!(scope.bool_type_id(), BOOL_TYPE_ID);

        assert!(scope.bool_type_id() != scope.array_type_id());
    }

    #[test]
    fn multiple_definitions() {
        let mut scope = ScopeStack::new();
        let type_id = scope.declare_type(Identifier::from("FooType"), ItemType::Primitive(1));
        assert_eq!(scope.lookup(&Identifier::from("foo")).len(), 0);

        scope.declare(Identifier::from("foo"), type_id);
        assert_eq!(scope.lookup(&Identifier::from("foo")).len(), 1);

        // Declaring the same name in the same scope should overwrite the
        // definition
        scope.declare(Identifier::from("foo"), type_id);
        assert_eq!(scope.lookup(&Identifier::from("foo")).len(), 1);

        scope.push_scope();
        // Declaring foo in another scope should add a definition
        scope.declare(Identifier::from("foo"), type_id);
        assert_eq!(scope.lookup(&Identifier::from("foo")).len(), 2);

        // Declaring the same name in the same scope should overwrite the
        // definition
        scope.declare(Identifier::from("foo"), type_id);
        assert_eq!(scope.lookup(&Identifier::from("foo")).len(), 2);
    }
}
